% Copyright 2017 Rebecca Skinner
%
% This work is licensed under the Creative Commons
% Attribution-ShareAlike 4.0 International License. To view a copy of
% this license, visit http://creativecommons.org/licenses/by-sa/4.0/
% or send a letter to Creative Commons, PO Box 1866, Mountain View, CA
% 94042, USA.
\documentclass{beamer}

\title{Tackling ``Tackling the Awkward Squad''}
\subtitle{}
\author{Rebecca Skinner\\ \small{@cercerilla}}
\institute{Papers We Love St. Louis}
\date{\today}

\mode<presentation> {\usetheme{metropolis}}

\usepackage[english]{babel}
\usepackage{times}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}
\usepackage{amsmath}
\usepackage{csquotes}
\usepackage{verbatim}
\usepackage{fontspec}
\usepackage{pbox}

\definecolor{comment}{rgb}{145,175,188}
\definecolor{keyword}{rgb}{157,163,199}
\definecolor{string}{rgb}{155,204,174}

\lstset{ % add your own preferences
  basicstyle=\tiny,
  showspaces=false,
  showtabs=false,
  numbers=none,
  numbersep=5pt,
  showstringspaces=false,
  stringstyle=\color[rgb]{0.16, .47, 0},
  tabsize=1
}

\newcommand{\chref}[3] {
  {\color{#1} \href{#2}{\underline{#3}}}
}

\AtBeginSection[]{
  \begin{frame}
    \vfill
    \centering
    \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
      \usebeamerfont{title}\insertsectionnumber \\ \insertsectionhead\par%
    \end{beamercolorbox}
    \vfill
  \end{frame}
}

\AtBeginSubsection[]{
  \begin{frame}
    \vfill
    \centering
    \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
      \usebeamerfont{title}\insertsectionnumber.\insertsubsectionnumber\\\insertsubsectionhead\par%
    \end{beamercolorbox}
    \vfill
  \end{frame}
}

\begin{document}
\begin{frame}
  \titlepage{}
  \begin{center}
    \small{\chref{blue}{http://creativecommons.org/licenses/by-sa/4.0/}{LICENSE}}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{The Paper}
  \begin{center}
    \emph{Tackling the Awkward Squad: monadic input/output, concurrency, exceptions, and foreign-language calls in Haskell}
    \vfill
    Simon Peyton Jones\\
    \emph{Microsoft Research, Cambridge}\\
    April 7, 2010
    \vfill
\chref{blue}{https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/mark.pdf}{link}
\end{center}
\end{frame}

\section{Introduction}
\begin{frame}
  \frametitle{About the Paper}
  Tackling The Awkward Squad looks at the real problems and solutions
  for writing applications in haskell.  It examines how monads, in
  particular, arose as a practical solution to real problems faced by
  language designers.
\end{frame}

\begin{frame}
  \frametitle{Understanding the Awkward Squad}
  The awkward squad is the name given to a few concepts that had
  proven difficult to implement with pure lazy semantics of languages
  like haskell.  In particular the awkward squad consists of:
  \begin{itemize}
    \item Input and Output
    \item Concurrency
    \item Exception Handling
    \item Interfacing with Other Languages
  \end{itemize}
\end{frame}
\begin{frame}
  \frametitle{What We'll Cover}
  The paper discusses both the language level constructs to tackle the
  awkward squad, as well as the denotional and operational semantics
  used to formalize the features for compiler implementers.  In this
  presentation we'll focus on the lingustic constructs and eschew the
  denotional and operational semantics of interest to compiler
  implementers.

  Futhermore, some specific areas of the paper will be omitted where
  there has been futher research that has advanced the state of the
  art beyond what was known at the time that this paper was written.
\end{frame}

\begin{frame}
  \frametitle{Why This is Cool- Even If You Don't Like Haskell}
  The awkward squad is not only a set of problems faced by the
  implementers of lazy functional languages- these are areas where
  practical work can be accomplished in all languages to simplify
  program design and reduce errors.  Understanding the approaches
  taken by language designers can have a material impact on how we
  address these concerns in other languages as well.
\end{frame}

\section{Input and Output}
\begin{frame}[fragile]
\begin{center}
\begin{lstlisting}[language=haskell]
primes :: [Integer]
primes = sieve [2..]
  where
sieve (p:xs) = p : sieve [x | x <- xs, x `mod` p > 0 ]
\end{lstlisting}
\end{center}
\end{frame}

\begin{frame}
  \frametitle{Solipsism}
  \emph{Solipsism} is the position in Metaphysics and Epistemology
  that the mind is the only thing that can be known to exist and that
  knowledge of anything outside the mind is unjustified.
\end{frame}

\begin{frame}
  \frametitle{Solipsistic Applications}
  A solipsistic application is a rather useless thing, unless we are
  trying to heat a cold room.  Without the ability to interact with
  the outside world a program cannot be of actual use.  This
  interaction requires receiving \emph{input} from the outside world,
  and providing \emph{output} to the world about the state or result
  of the program.
\end{frame}

\begin{frame}
  \frametitle{The Problem of IO}
  Input and Output (IO) can the the cause of some consternation for a
  pure lazy language.  In the next few slides we'll take a look at
  some specific issues that the paper raises regarding IO in languages
  like haskell.
\end{frame}

\begin{frame}
  \frametitle{Lazy Evaluation?}
  Lazy evaluation complicates the notion of input and output because
  there is no concept of strict ordering for when input and output
  should occur.
\end{frame}

\begin{frame}[fragile]
  \frametitle{The Problem of Sequencing}
  Much of the problem of lazy evaluation is also one of sequencing.  Consider the program snippet below:
\begin{lstlisting}[language=haskell]
results = [ print "hello", print "world", print "!" ]
\end{lstlisting}
  In this example, there is no clear way for us to understand which
  order the print statements should be evaluated in a lazy language.
\end{frame}

\begin{frame}[fragile]
  \frametitle{A Change in the World}
  Input and output are problematic not just from a lazy evaluation and
  sequencing standpoint- input and output also make functions impure
  because they rely on external effects.  Imagine the following
  pseudocode application below which appends a number of 0's to a file
  each call equivalent to half the remaining disk space:

\begin{lstlisting}
fn effectfulFunction: Integer
  let fileSize <- availableDiskSpace / 2
  let fileData <- repeat '0' for fileSize
  appendFile "/tmp/log" fileData
  return fileSize
\end{lstlisting}

  Each call to this subroutine will affect the external state of the
  machine in a way that means that we cannot treat this as a pure
  function.
\end{frame}
\begin{frame}
  \frametitle{What we Need}
  Solving the problem of input and output requires two notions:
  \begin{itemize}
  \item A way of keeping track of the state of the world, so that we
    can capture changes to the state of the world, representing side
    effects in a pure way
  \item A way of forcing a specific sequence of evaluation, in order
    to ensure that we are able to represent the dependencies between
    effects.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Monads}
  Monads provided a convenient mathematical notion for how to manage
  both carrying additional context around a value, and a way to
  enforce sequencing on operations in a lazy language.

\begin{lstlisting}[language=haskell]
class Monad m where
  return :: a -> m a
  (>>=)  :: m a -> (a -> m b) -> m b
  (>>)   :: m a -> m b -> m b
\end{lstlisting}
\end{frame}

\begin{frame}
  \frametitle{Other Things That Are Secretly IO}
  As we start to pick apart the things that involve a persisent world
  state there are several other patterns that we can observe fall
  under the same umbrellas a basic text input and output:
  \begin{itemize}
  \item looping
  \item mutable variables
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Do Notation}
  As we start to look at implementations and use of various features
  that are implemented using the monadic io-actions, we start to
  observe how syntactic sugar will allow us to make the language more
  familiar and easier to update.  Consider:
\begin{lstlisting}[language=haskell]
readTwoWriteFour :: IO ()
readTwoWriteFour =
  getChar >>= \fstChr ->
    getChar >>= \sndChar ->
      putChar fstChr >>
        putChar sndChr >>
          putChar fstChr >>
            putChar sncChr
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  By introduction the do notation wich adds implicit bind operations
  and lambda creation, we can simplify monadic code into something
  that more intituitvely resembles it's semantics:
\begin{lstlisting}[language=haskell]
readTwoWriteFour :: IO
readTwoWriteFour = do
  fstChr <- getChar
  sndChr <- getChar
  putChar fstChar; putChar sndCar
  putChar fstChar; putChar sndCar
\end{lstlisting}
\end{frame}
\begin{frame}
  \frametitle{Questions?}
  Questions about Input and Output?
\end{frame}

\section{Concurrency}
\begin{frame}
  \frametitle{Concurrency and Parallelism}
  Before we begin looking at managing concurrency and parallelism
  let's take a brief look at the difference between the two:
  \begin{itemize}
  \item \emph{Parallelism} uses multiple threads of execution (across
    logical or physical cores, processors, or computers) in order to
    increase performance of an algorithm.  Parallelism is an
    implementation detail that does not affect the semantics of the
    application.
  \item \emph{Concurrency} is when multiple independent threads of
    execution are simultaneously executed.  The program may or may not
    be distributed across many individual threads, but the execution
    is non-deterministic and semantically impacts program execution.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fork}
\begin{lstlisting}[language=haskell]
forkIO :: IO a -> IO ThreadId
\end{lstlisting}
  forkIO is a function that takes an IO action and returns a
  worldstate with a thread ID, representing the IO action's concurrent
  execution state that runs alongside the parent state.  IO actions
  may be interleaved and the use of monadic sequencing does not
  obviate race conditions or other concurrency related bugs.
\end{frame}

\begin{frame}
  \frametitle{MVars and STM}
  The idea of MVars is introduced as a mechanism to allow safe
  coordination between concurrent threads of execution.  By leverating
  monadic sequencing across concurrent execution threads to introduce
  blocking reads and writes at the IO action level, we can allow
  dependent values to enforce sequencing across different threads of
  execution.

  In addition to the MVars discussed in the paper, substantial
  research has been done on software transactional memory.  STM is a
  monadic construct that offers more semantic correctness guarantees
  at a substantial performance cost.  See: \chref{blue}{https://simonmar.github.io/bib/papers/stm.pdf}{Composable Memory Transactions}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Channels}
  It is often helpful to consider having a directional method of
  communication between threads or processes in order to manage
  communication.  Channels allow just this.  By providing MVars (or
  STMs) for input and output we are able to create channels and
  streams of data for managing unidirectional data stream:
\begin{lstlisting}[language=haskell]
type Channel a = (MVar (Stream a), MVar (Stream a))
type Stream a = MVar (Item a)
type Item a = MkItem a (Stream a)
\end{lstlisting}
\end{frame}
\begin{frame}
  \frametitle{Questions?}
  Questions about Concurrency?
\end{frame}

\section{Exception Handling}
\begin{frame}
  \frametitle{Throw and Catch}
  Many operations dealing with input and output can fail, and may fail
  nondeterministically.  Additionally, many failure conditions, such
  as timeouts and non-terminating states may not be representable as a
  return value from a pure function.  Since IO actions represent a
  context around effectful functions, we can encapsulate the notion of
  exceptional failure in this context, allowing us to create throw and
  catch exception handling that operates at the monadic action level:
\end{frame}

\begin{frame}[fragile]
  \frametitle{Throw and Catch}
\begin{lstlisting}[language=haskell]
ioError :: IOError -> IO a
catch :: IO a -> (IOError -> IO a) -> IO a
\end{lstlisting}
  We use \emph{ioError} as our mechanism to throw an exception.  Catch
  takes an IO action, and a function that is called when an IO
  Exception is encountered.  It either returns the IO action, or else
  the result of the handler when given the encountered IO action.
\end{frame}

\begin{frame}
  \frametitle{Pure Exceptions}
  Pure code may not throw exceptions due to the limitations caused by
  lazy evaluation.  Because of this, pure functions that may fail (for
  example, partial functions) may be lifted into IO to handle
  exceptions.  It is also possible to use other monadic
  representations of exception handling.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Async Exceptions}
\begin{lstlisting}[language=haskell]
throwTo :: ThreadId -> Exception -> IO ()
\end{lstlisting}
  In many cases, it is useful to be able to handle exxceptions
  asynchronously, or across different execution threads.  By allowing
  us to throw exceptions across thread boundries we can manage
  resource allocation, multiple execution threads, and managing
  timeouts:
\end{frame}
\begin{frame}[fragile]
  \frametitle{Timeouts}
\begin{lstlisting}[language=haskell]
-- parIO takes two IO actions and run them in parallel, returning the result
-- that finishes first, then terminates both
parIO :: IO a -> IO a -> IO a
parIO a1 a2 = do
  m <- newEmptyMVar
  c1 <- forkIO (child m a1)
  c2 <- forkIO (child m a2)
  r <- takeMVar m
  throwTo c1 Kill; throwTo c2 Kill
  return r
  where
    child m a = do {r <- a; putMVar m r}

timeout :: Int -> IO a -> IO (Maybe a)
timeout n a = parIO (do {r <- a; return (Just r) })
                    (do { threadDelay n; return Nothing})
\end{lstlisting}
\end{frame}

\begin{frame}
  \frametitle{Questions?}
  Questions about Exception Handling?
\end{frame}

\section{Foreign-Language Calls}

\begin{frame}
  \frametitle{Phantom Types}
  The paper makes several references, both explicit and implicitly, to
  the concent of phantom types.  Before we delve into the details of
  FFI calls in haskell let's take a moment to understand what phantom
  types are and how they can best be used:
\end{frame}

\begin{frame}[fragile]
  \frametitle{Phantom Types: Example}
\begin{lstlisting}[language=haskell]
data Connected = Connected        -- unexported
data Disconnected = Disconnected  -- unexported
data DatabaseConnection a = DatabaseConnection ... implementation ...

connect :: DatabaseConnection Disconnected -> DatabaseConnection Connected
connect = ...

disconnect :: DatabaseConnection Connected -> DatabaseConnection Disconnected
disconnect = ...
\end{lstlisting}
\end{frame}

\begin{frame}
  \frametitle{Phantom Types: Cont}
  Phantom types allow us to associated specific information at the
  type level with a value, even when a value of that type isn't
  represented in the internal representation of the type.  In the
  example above, while the database connection type has no values of
  type Connected or Disconnected, we can use those as type parameters
  to ensure that we are only working with a database connection that
  has been actively connected, or hasn't, as the function requires.
\end{frame}

\begin{frame}
  \frametitle{Calling To and From C}
  It is desirable to be able to interoperate with code written in
  other languages.  In the specific case, we wish to be able to both
  use code written in C as well as to provide code that can be called
  by C.  The choice of C as a lanaguage is not elaborated on in the
  paper, but we may assume that this is due to the C ABI as a widely
  accepted language of interoperability across many different
  operating systems and hardware architectures.
\end{frame}

\begin{frame}[fragile]
  \frametitle{ccall}
  The ccall directive provides a mechanism for us to explicitly
  annotate functions that are imported or exported for
  interoperatbility with external applications.
\begin{lstlisting}[language=haskell]
foreign import ccall fizzbuzz :: Int -> IO ()
foreign export ccall foobar :: Float -> IO Float
\end{lstlisting}

  Explicit annotation of these functions allows the compiler to emit
  code that allows the code to be represented in a way necessary for
  linking with other codebases.  By using the IO monad to explicity
  differentiate between pure and effectful code we can manage to
  bridge the gap between pure lazy code and impure strict code.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Dynamic Calls}
  Dynamic functions are implemented by creating an explict type to
  manage function pointers.  This allows us to interoperate with
  functions that expect callbacks by treating them as data that
  represents an underlying first-class function from within the
  context of haskell's semantics.
\begin{lstlisting}[language=haskell]
foreign import ccall "dynamic" foo :: FunPtr (Int -> IO Int) -> Int -> IO Int
\end{lstlisting}
\end{frame}

\begin{frame}
  \frametitle{Marshalling}
  Marshalling is the process of converting haskell datatypes into a
  format where they can be explicitly shared to code in other
  languages.  By leveraging the IO monad to manage effects and strict
  sequencing we are able to create an \emph{Storable} typeclass that
  allows us to directly manipulate bytes in the system state.
\end{frame}

\begin{frame}
  \frametitle{Memory Management}
  By using IO actions to encapsulate the context of allocated and
  freed memory in the system, we can create safe garbage collected
  memory management that allows us to create type safe pointers to
  both stable haskell-owned memory locations as well as
  foreign-managed objects.
\end{frame}
\section{Questions?}
\end{document}
