#+title: Make It Purple
#+SUBTITLE: An Introduction to Type Level Programming
#+institution: Mercury
#+author: Rebecca Skinner
#+BEAMER_FRAME_LEVEL: 2
#+options: toc:nil H:2 num:t
#+LaTeX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [10pt, presentation, colorlinks]
#+LaTeX_HEADER: \usecolortheme{magpie}
#+LaTeX_HEADER: \usepackage{minted}
#+LaTeX_HEADER: \usemintedstyle{monokai}
#+LaTeX_HEADER: \newminted{haskell}{}
#+BEAMER_HEADER:\AtBeginSection[]{\begin{frame}<beamer>\frametitle{}\center{\huge{\secname}}\end{frame}}
#+startup: beamer

#+date: \today

* Prelude

** Hello, World
- Rebecca Skinner: Me
- Mercury: My Employer (We're Hiring)
- The Ideas and Contents of this Talk: My Own
- Effective Haskell: My Book! (Est. late 2021 / early 2022)
- [[https://twitter.com/cercerilla][@cercerilla: Twitter]]
- [[https://rebeccaskinner.net/posts/2021-08-25-introduction-to-type-level-programming.html][Slides and Code: https://rebeccaskinner.net]]

#+ATTR_LATEX: :height 0.3\textheight
[[file:img/url.png]]

* Building A Theming Engine for XMonad

** XMonad: Purple Edition

[[file:img/screenshot.png]]

** Let's Build It!

On the surface, a theming system doesn't need to be very complicated.

#+beamer: \pause

#+begin_src haskell :exports code
  polybarColorScheme = PolybarColorScheme
    { focusedWorkspaceText        = "#dda0dd"
    , focusedWorkspaceBackground  = "#2a2035"
    , visibleWorkspaceText        = "#dda0dd"
    , visibleWorkspaceBackground  = "#2a2035"
    }
#+end_src

#+beamer: \pause

But now a change to our theme means changing every individual element.

#+begin_src haskell :exports code
  stylishConfig :: XConfig a -> XConfig a
  stylishConfig cfg = cfg
    { normalBorderColor  = "#dda0dd"
    , focusedBorderColor = "#2a2035"
    }
#+end_src

** With A Color Palette

One solution to allow us to uniformly change our color scheme would be
to use a /color palette/.

#+beamer: \pause

#+begin_src haskell :exports code
  data RGB = RGB
    { rgbRed   :: Word8
    , rgbGreen :: Word8
    , rgbBlue  :: Word8
    } deriving (Eq, Show)

  type ColorPalette = Map Text RGB

  defaultPalette = fromList $
    [ ("foreground", RGB 0x3a 0x20 0x35)
    , ("background", RGB 0xdd 0xa0 0xdd) ]
#+end_src

** Theming With A Color Palette

Now we can consistently reference colors by their name.

#+begin_src haskell :exports code
  polybarColorScheme :: ColorPalette -> Maybe PolybarColorScheme
  polybarColorScheme theme = PolybarColorScheme
    <$> theme !? "foreground"
    <*> theme !? "background"
    <*> theme !? "foreground"
    <*> theme !? "background"
#+end_src

** Missing Information

This buys us some consistency, but we still have problems:

#+beamer: \pause
1. Every component needs to know ahead of time what keys are available in the palette
2. We can't easily tell what parts of a palette are being used, making maintenance harder
3. We can't statically guarantee that our theme will work
#+beamer: \pause

Runtime errors can be painful when we're configuring a desktop
environment, because it might mean that we have to fix everything from
a terminal.

* Using The Type System To Improve Our Theming System

** Needs More Type System

Let's look at how we can use the type system to help make our theming
system easier to use.

#+beamer: \pause

Here's what we'd like to do:

#+beamer: \pause

- Ensure that the type of any function that uses theme elements tells what elements it uses

#+beamer: \pause

- Ensure that we can't pass a theme to a function if it's missing required elements

** But First, A Demo

Our ~colorDemo~ function lets us get colors from a ~theme~ by
name. Instead of passing the color we want as a string, we're using
/visible type applications/ to pass in the color as a /type/.

#+begin_src haskell :exports code
  {-# LANGUAGE TypeApplications #-}

  colorDemo theme =
    let r = lookupColor @"red" theme
        g = lookupColor @"green" theme
        b = lookupColor @"blue" theme
    in show (r,g,b)
#+end_src

** But First, A Demo

The type of ~colorDemo~ can be inferred for us, and tells us exactly
which colors must be available in our theme.

#+begin_src haskell :exports code
  {-# LANGUAGE TypeApplications #-}

  colorDemo
    :: ( HasColor "red" theme
       , HasColor "green" theme
       , HasColor "blue" theme )
    => ThemeInstance theme -> String
  colorDemo theme =
    let r = lookupColor @"red" theme
        g = lookupColor @"green" theme
        b = lookupColor @"blue" theme
    in show (r,g,b)
#+end_src

** Let's Make A Theme Instance

Our demo referenced a ~ThemeInstance~ type that holds theme
information, so let's make one.

#+beamer:\pause
#+begin_src haskell :exports code
  newtype ThemeInstance                  =
    ThemeInstance { getThemeInstance :: Map String RGB }
    deriving Show
#+end_src

** A Theme Instance With Phantom Types

We need to keep track of all of the theme elements that belond to the
theme somehow.

\vspace{5mm}
#+beamer:\pause
We can use a /phantom type/ to hold the list of colors in our theme.
\vspace{5mm}

#+beamer:\pause
#+begin_src haskell :exports code
  newtype ThemeInstance  theme           =
    ThemeInstance { getThemeInstance :: Map String RGB }
    deriving Show
#+end_src


** A Phantom Type With a Theme Kind

Let's make a theme instance!

#+beamer:\pause
#+begin_src haskell :exports code
  myTheme :: ThemeInstance (Int, Either String Bool)
  myTheme = ThemeInstance Map.empty
#+end_src
#+beamer:\pause
\big{No...}
#+beamer:\pause

We can constrain ~theme~ by giving it a /Kind Signature/. Here we're
saying the *kind* of ~theme~ must be ~Theme~.

#+beamer:\pause
#+begin_src haskell :exports code
  newtype ThemeInstance (theme :: Theme) =
    ThemeInstance { getThemeInstance :: Map String RGB }
    deriving Show
#+end_src

** How Kind of You

When we're programming at the value level, we tend to think in terms
of /types/ and /values/. A *type* has /inhabitants/ that are plain
haskell values. For example, the ~Bool~ type has two inhabitants:
~True~ and ~False~.
#+beamer:\pause
A *kind* is analogous to a type, but where the inhabitants of a type
are values, the inhabitants of a kind are types. In other words,
/kinds are the types of types/.

* Defining A Theme At The Type Level

** What Is a Theme?

We said that ~ThemeInstance~ has a phantom type parameter with the
*kind* ~Theme~, but what is a ~Theme~ anyway?

#+ATTR_BEAMER: :overlay <+->
- A collection of colors
- Known at compile time
- Identifiable with a name like /"red"/ or /"foreground"/

** Colors At The Type Level

A ~Theme~ is a collection of type-level colors, so we need to define
what a color looks like at the type level.

** Theme Elements By Name

We want to refer to theme elements by name (/"red"/, /"green"/,
/"blue"/). We could define types for all the colors:
#+begin_src haskell :exports code
  data Red
  data Green
  data Blue
#+end_src
#+beamer:\pause
But what a pain! We could try to enumerate every named color, but it
would be a nightmare. Instead, let's use /type-level strings/

** Symbolism

A Symbol is a type-level ~String~.

#+beamer:\pause

#+begin_src haskell :exports code
  > :kind "green"
  "green" :: Symbol
#+end_src

#+beamer:\pause

~KnownSymbol~ is a typeclass that let's us get a string from a symbol.

#+begin_src haskell :exports code
  > symbolVal $ Proxy @"green"
  "green"
  > :t symbolVal
  symbolVal :: KnownSymbol n => proxy n -> String
#+end_src

** A Theme Of Many Colors

Great. But we want a /Theme/ not a single color.

#+beamer:\pause

#+begin_src haskell :exports code
  type Theme = [Symbol]
#+end_src

** Checking The Colors In A Theme

We have a list of colors now. But it the right list?
#+beamer:\pause
#+begin_src haskell :exports code
  lookupColor
    :: forall colorName theme.
    ( KnownSymbol colorName
    , HasColor colorName theme)
    => ThemeInstance theme
    -> RGB
#+end_src

** Implementing ~HasColor~

The secret is in ~HasColor~
#+beamer:\pause
#+begin_src haskell :exports code
  class HasColor (color :: Symbol) (container :: Theme)
#+end_src
#+beamer:\pause

To make ~HasColor~ work, we need recursion. We'll start with a base
case:

#+beamer:\pause
#+begin_src haskell :exports code
  instance HasColor color (color : colors)
#+end_src
#+beamer:\pause

We'll call the recursive case if the head of the theme isn't what we
want.

#+beamer:\pause
#+begin_src haskell :exports code
  instance                      (HasColor color colors)
    => HasColor color (currentColor : colors)
#+end_src

** Dealing with Overlapping Instances

And now we have a problem.

#+ATTR_BEAMER: :overlay <+->
- ~color~ and ~color~ are always the same.
- ~color~ and ~currentColor~ _might be the same_.

#+begin_src haskell :exports code
  instance {-# OVERLAPPABLE #-} (HasColor color colors)
    => HasColor color (currentColor : colors)
#+end_src

** Getting A Theme Element

~HasColor~ Accomplished. Let's get colorful.

#+beamer:\pause
#+begin_src haskell :exports code
  lookupColor
    :: forall colorName theme.
    ( KnownSymbol colorName
    , HasColor colorName theme)
    => ThemeInstance theme -> RGB
  lookupColor (ThemeInstance colors) =
    let
      targetName = symbolVal $ Proxy @colorName
    in colors Map.! targetName
#+end_src

** Demo

#+begin_src haskell :exports code
  demoThemeInstance :: ThemeInstance ["red","green","blue"]
  demoThemeInstance = ThemeInstance . Map.fromList $
    [("red", RGB 0xff 0x00 0x00)
    ,("green", RGB 0x00 0xff 0x00)
    ,("blue", RGB 0x00 0x00 0xff)]
#+end_src

#+beamer:\pause
We succeed when we should.
#+begin_src haskell :exports code
  > lookupColor @"red" demoThemeInstance
  RGB {rgbRed = 255, rgbGreen = 0, rgbBlue = 0}
#+end_src

#+beamer:\pause
More importantly, we fail when we should.
#+begin_src haskell :exports code
  > lookupColor @"yellow" demoThemeInstance

  <interactive>:80:1: error:
      • No instance for (HasColor "yellow" '[])
          arising from a use of ‘lookupColor’
      • In the expression: lookupColor @"yellow" demoThemeInstance
        In an equation for ‘it’:
            it = lookupColor @"yellow" demoThemeInstanc
#+end_src

* Building A Better Theme Instance

** Mind The Gap

#+begin_src haskell :exports code
  > :t demoThemeInstance
  demoThemeInstance :: ThemeInstance ["red","green","blue"]

  > lookupColor @"blue" demoThemeInstance
    ,*** Exception: Map.!: given key is not an element in the map
    CallStack (from HasCallStack):
      error, called at
        libraries/containers/containers/src/Data/Map/Internal.hs:627:17
        in containers-0.6.2.1:Data.Map.Internal
#+end_src
#+beamer:\pause
But we don't _always_ fail when we should

** An Instance of Weakness

What happened?
#+beamer:\pause
#+begin_src haskell :exports code
  demoThemeInstance :: ThemeInstance ["red","green","blue"]
  demoThemeInstance = ThemeInstance . Map.fromList $
    [("red", RGB 0xff 0x00 0x00)]
#+end_src

** Fixing The Problem

We need to construct the theme and the value at the same time.

** Colors At The Type Level: Part 2

Our goal: Capture all of the relevant information about a color at
compile time.

** X11 Colors At The Type Level

We can build a type-level color pallet with X11 colors.

#+begin_src haskell :exports code
  data RebeccaPurple = RebeccaPurple
#+end_src
#+beamer:\pause
But that's a lot of typing

#+begin_src shell
  user@host$ wc -l ColorX11.hs
  1488 ColorX11.hs
#+end_src
#+beamer:\pause
And we're still limited to a fixed palette of colors.


** Type Level RGB

What if RGB, but at the type level?
#+beamer:\pause
#+begin_src haskell :exports code
  data RGBColor (r :: Nat) (g :: Nat) (b :: Nat) = RGBColor
#+end_src

** Type Level RGB Is A Color

We still need to get a runtime representation of color.

#+beamer:\pause
#+begin_src haskell :exports code
  class IsColor a where
    toRGB :: a -> RGB

  instance IsColor RGB where
    toRGB = id

  instance IsColor RebeccaPurple where
    toRGB = const $ RGB 0x66 0x33 0x99
#+end_src

** The RGB Problem

#+begin_src haskell :exports code
  toRGB (RGBColor @975 @2148 @8)
#+end_src

** Making an ~RGBColor~ Type Into a Runtime Value

Ok, how about only _valid_ RGB Colors are colors?

#+beamer:\pause
We can use ~ConstraintKinds~ to create an alias for this set of constraints:

#+begin_src haskell :exports code
  type ValidRGB r g b =
    ( KnownNat r, KnownNat g, KnownNat b
    , r <= 255, g <= 255, b <= 255)
#+end_src

** Converting an RGBColor Into A Runtime RGB Value

#+begin_src haskell :exports code
  instance ValidRGB r g b => IsColor (RGBColor r g b) where
    toRGB _ = RGB (natWord8 @r) (natWord8 @g) (natWord8 @b)
#+end_src

** The ~RGBColor~ Problem

#+begin_src haskell :exports code
  polybarColorScheme = PolybarColorScheme
    { focusedWorkspaceText        = RGBColor :: RGBColor 255 255 255
    , focusedWorkspaceBackground  = RGBColor :: RGBColor 0 0 0
    --- more like this
#+end_src
#+beamer:\pause
Remind you of anything?
#+beamer:\pause
#+begin_src haskell :exports code
  polybarColorScheme = PolybarColorScheme
    { focusedWorkspaceText        = "#dda0dd"
    , focusedWorkspaceBackground  = "#2a2035"
#+end_src

** The Hardest Problem in Computer Science

The next in a series of problems

#+ATTR_BEAMER: :overlay <+->
- We've got type level names for colors: ~Symbol~
- We've got type level colors: ~RGBColor~
- We've got no way to connect them together

** Type Families

We need a _function_ from ~RGBColor r g b~ to ~Symbol~
#+beamer:\pause
\vspace{5mm}
A function between types is called a *Type Family*

** Creating A Type Family For Color Names

#+begin_src haskell :exports code
  class IsColor a => NamedColor a where
    type ColorName a :: Symbol
#+end_src

~ColorName~ is an /associated type family/

#+beamer:\pause

#+begin_src haskell :exports code
  colorNameVal :: forall a. KnownSymbol (ColorName a) => String
  colorNameVal = symbolVal $ Proxy @(ColorName a)
#+end_src

** Simple NamedColor Instances

Creating a named color for the colors in our color palet is easy.

#+begin_src haskell :exports code
  instance NamedColor RebeccaPurple where
    type ColorName RebeccaPurple = "RebeccaPurple"
#+end_src

** When In Doubt, Hardcode It

To name an RGBColor, we just give it a name:
#+beamer:\pause

#+begin_src haskell :exports code
  data NamedRGB (name :: Symbol) (r :: Nat) (g :: Nat) (b :: Nat) = NamedRGB

  instance ValidRGB r g b => IsColor (NamedRGB name r g b) where
    toRGB _ = toRGB $ (RGBColor :: RGBColor r g b)

  instance IsColor (NamedRGB name r g b)
    => NamedColor (NamedRGB name r g b) where

    type ColorName _ = name
#+end_src

** Renaming Things Is An Even Harder Problem

But we really should support naming ~RGBColor~ too:

#+beamer:\pause
#+begin_src haskell :exports code
  λ colorNameVal @(RGBColor 0 190 239)
  "#00BEEF"
#+end_src

** Hexing The Type Families

~NatHex~ is a /Closed Type Family/ from ~Nat~ to ~Symbol~

** Casting Hexes

#+begin_src haskell :exports code
  type family NatHex (n :: Nat) :: Symbol where
    NatHex 0  = "0"
    NatHex 1  = "1"
    NatHex 2  = "2"
    -- And so on
    NatHex 14 = "E"
    NatHex 15 = "F"
    NatHex n = NatHex (Div n 16) `AppendSymbol` NatHex (Mod n 16)
#+end_src
#+beamer:\pause
#+begin_src haskell :exports code
  > :kind! NatHex 11
  NatHex 11 :: Symbol
  = "B"
  > :kind! NatHex 250
  NatHex 250 :: Symbol
  = "FA"
#+end_src

** Padding, Part 1

Let's pad those numbers

#+begin_src
if the number is less than 15:
  return "0" prepended to the stringified value
else:
  return the stringified value
#+end_src

** It's Looking Kind of Iffy

*If* it were only so easy...
#+beamer:\pause
#+begin_src haskell :exports code
  type family IfThenElse (p :: Bool) (t :: a) (f :: a) where
    IfThenElse True t f = t
    IfThenElse False t f = f
#+end_src

** Bringing It All Together

#+begin_src haskell :exports code
  type family PadNatHex (n :: Nat) :: Symbol where
    PadNatHex n =
      IfThenElse (n <=? 15) ("0" `AppendSymbol` NatHex n) (NatHex n)
#+end_src

#+beamer:\pause
Using ~PadNatHex~ we can now also write an instance of ~NamedColor~
for plain ~RGBColor~ types:

#+beamer:\pause
#+begin_src haskell :exports code
  instance IsColor (RGBColor r g b) => NamedColor (RGBColor r g b) where
    type ColorName _ =
      (("#" `AppendSymbol` PadNatHex r)
        `AppendSymbol` PadNatHex g
      ) `AppendSymbol` PadNatHex b
#+end_src

* Constructing A Theme Instance With ~NamedColor~

** What's Old Is New Again

Let's make a well-typed theme at runtime.
\vspace{5mm}
#+beamer:\pause
A runtime function needs to be called with /values/
\vspace{5mm}
#+beamer:\pause
So we need _A Function from Values to Types_.

** MkTheme

A *GADT* is a function from a value to a type

#+begin_src haskell :exports code
  data MkTheme theme where
    NewTheme :: MkTheme '[]
    AddColor :: (KnownSymbol (ColorName color), NamedColor color)
             => color
             -> MkTheme theme
             -> MkTheme (ColorName color : theme)
#+end_src

** ~MkTheme~-ing A ~ThemeInstance~

What we build up, we must tear down.

#+begin_src haskell :exports code
  instantiateTheme :: MkTheme theme -> ThemeInstance theme
#+end_src

** ~MkTheme~-ing A ~ThemeInstance~

What we build up, we must tear down.

#+begin_src haskell :exports code
  instantiateTheme :: MkTheme theme -> ThemeInstance theme
  instantiateTheme NewTheme = ThemeInstance Map.empty
#+end_src

** ~MkTheme~-ing A ~ThemeInstance~

What we build up, we must tear down.

#+begin_src haskell :exports code
  instantiateTheme :: MkTheme theme -> ThemeInstance theme
  instantiateTheme NewTheme = ThemeInstance Map.empty
  instantiateTheme (AddColor color mkTheme') =
    let
      (ThemeInstance t) = instantiateTheme mkTheme'
      colorName = colorNameVal' color
      colorVal = SomeColor $ toRGB color
    in ThemeInstance $ Map.insert colorName colorVal t
#+end_src

** A ~MkTheme~ Demo

Let's try it out:
#+beamer:\pause
#+begin_src haskell :exports code
  sampleColorSet =
    instantiateTheme $
    AddColor (namedRGB @"red"   @255 @0   @0)   $
    AddColor (namedRGB @"green" @0   @255 @0)   $
    AddColor (namedRGB @"blue"  @0   @0   @255) $
    NewTheme

  sampleThemer theme = show
    ( lookupColor @"red" theme
    , lookupColor @"green" theme
    , lookupColor @"blue" theme)
#+end_src
#+beamer:\pause
#+begin_src haskell :exports code
  > sampleThemer sampleColorSet
  (RGB {rgbRed = 255, rgbGreen = 0,   rgbBlue = 0}
  ,RGB {rgbRed = 0,   rgbGreen = 255, rgbBlue = 0},
  ,RGB {rgbRed = 0,   rgbGreen = 0,   rgbBlue = 255})
#+end_src

* Generating A Runtime Theme Configuration

** Runtime Configuration

Users don't like to compile things. Let's make it work at runtime too.


#+beamer:\pause
\vspace{5mm}


At the cost of some safety.

** ~theme.json~

At least it's not YAML...

#+begin_src json :exports code
  {
      "red": {"rgb": "#ff0000"},
      "green": {"rgb": "#00ff00"},
      "blue": {"x11": "AliceBlue"},
      "text": {"same-as": "blue"},
      "border": {"same-as": "text"}
  }
#+end_src

** Defining The Theme Config Format

Another dictionary will solve things

#+begin_src haskell :exports code
  newtype ThemeConfig = ThemeConfig
    {getThemeConfig :: Map.Map String ColorValue}
#+end_src

** Creating A Runtime Color Value

Sometimes things are easy

#+begin_src haskell :exports code
  data ColorValue
    = RGBValue RGB
    | X11Value SomeColor
#+end_src
#+beamer:\pause
And sometimes they are hard: What about references?

** Reader References

Let's use monad transformers for some reason.

#+begin_src haskell :exports code
  newtype ColorReference r a =
    ColorReference {unColorReference :: ExceptT String (Reader r) a}
    deriving newtype (Functor, Applicative, Monad, MonadReader r)

    data ColorValue
      = RGBValue RGB
      | X11Value SomeColor
      | OtherColor (ColorReference ThemeConfig ColorValue)
#+end_src

** The Reader Problem

This kind of sucks.

#+ATTR_BEAMER: :overlay <+->
- Using reader might fail
- And it might not fail immediately
- And it's not very ergonomic

** Strictly Evaluating A Color Value

Is this /Strict Haskell/ ?

#+begin_src haskell :exports code
  data StrictColorValue
    = StrictRGBValue RGB
    | StrictX11Value SomeColor
    | StrictOtherColor StrictColorValue

  strictlyEvaluateColorValue :: ColorValue -> Either String StrictColorValue
#+end_src

** Custom Reader References

Let's try it agian without gratuitious duplication.

** The Higher-Kinded Data Pattern

#+begin_src haskell :exports code
  type family HKD (wrapper :: Type -> Type) (value :: Type) :: Type where
    HKD Identity value = value
    HKD wrapper value = wrapper value
#+end_src

** Using Higher-Kinded Data Improve ~ColorValue~

Using HKD is easy, if a little odd looking.

#+begin_src haskell :exports code
  data ColorValue w
    = RGBValue RGB
    | X11Value SomeColor
    | OtherColor (HKD w (ColorValue w))
#+end_src

** Updating ~ThemeConfig~

Better parameterize ~ThemeConfig~ too or we've just moved the problem around.

#+begin_src haskell :exports code
  newtype ThemeConfig w = ThemeConfig
    {getThemeConfig :: Map.Map String (ColorValue w)}
#+end_src

** Infinite Failure

#+begin_src haskell :exports code
  newtype ThemeConfig w = ThemeConfig
    {getThemeConfig :: Map.Map String (ColorValue w)}
#+end_src

If a ~ColorValue~ References a theme config, the type of ~w~ must be:

#+beamer:\pause
#+begin_src haskell
  ColorValue (ColoreReference (ThemeConfig (ColorReference (ThemeConfig ...
#+end_src

** Wrapping Up The Theme Config

This is a problem we /can/ solve by just not looking at it.

#+begin_src haskell :exports code
  newtype ThemeConfig' w = ThemeConfig'
    {getThemeConfig :: Map.Map String (ColorValue w)}

  type ThemeConfig = ThemeConfig' Identity

  newtype RawThemeConfig = RawThemeConfig
    { getRawThemeConfig :: ThemeConfig' (ColorReference RawThemeConfig) }
#+end_src

** Evaluating The ~ThemeConfig~

Strictly evaluating our references is looking a lot better now

#+begin_src haskell :exports code
  evalConfig :: RawThemeConfig -> Either String ThemeConfig
  evalConfig = undefined
#+end_src

** ~ThemeConfig~ Demo

#+begin_src haskell :exports code
  > loadThemeConfig "../theme.json"
  ThemeConfig'
    {getThemeConfig = fromList
      [ ("blue",X11Value RGB {rgbRed = 240, rgbGreen = 248, rgbBlue = 255})
      , ("border",OtherColor (OtherColor (X11Value RGB {rgbRed = 240, rgbGreen = 248, rgbBlue = 255})))
      , ("green",RGBValue (RGB {rgbRed = 0, rgbGreen = 255, rgbBlue = 0}))
      , ("red",RGBValue (RGB {rgbRed = 255, rgbGreen = 0, rgbBlue = 0}))
      , ("text",OtherColor (X11Value RGB {rgbRed = 240, rgbGreen = 248, rgbBlue = 255}))]}
#+end_src

* Integrating The Runtime and Type Level Theming Systems

** Bringing It All Together

- We have typesafe theme configuration.

\vspace{5mm}

- And a way to load a theme at runtime.

\vspace{5mm}

- Again, let's make these work together.

** Theme Validation

Validation is a function from a type-level ~Theme~ to a value-level ~ThemeInstance~

\vspace{5mm}

Functions from types to values are /type classes/ so let's start there.
#+beamer:\pause
#+begin_src haskell :exports code
  class ValidateThemeInstance (theme :: Theme) (a :: Theme -> Type) where
    validateThemeInstance :: Map String SomeColor -> Either String (a theme)

  instance ValidateThemeInstance '[] ThemeInstance where
    validateThemeInstance theme = Right (ThemeInstance theme)
#+end_src

** Stepping Through Theme Validation

#+begin_src haskell :exports code
  instance ( KnownSymbol currentColor
           , ValidateThemeInstance rest ThemeInstance
           ) => ValidateThemeInstance (currentColor:rest) ThemeInstance where
    validateThemeInstance theme =
      let targetColor = symbolVal $ Proxy @currentColor
      in case Map.lookup targetColor theme of
        Nothing ->
          let colorName = symbolVal $ Proxy @currentColor
          in Left $ "missing color: " <> colorName
        Just _ -> do
          (ThemeInstance m) <- validateThemeInstance @rest theme
          pure $ ThemeInstance m
#+end_src

** Runtime Theme Config Demo

Let's look at how we can use this in a real program

#+begin_src haskell :exports code
  type RuntimeTheme = ["blue", "green", "red"]
  validateThemeConfig
    :: forall (theme :: Theme).
       ValidateThemeInstance theme ThemeInstance
    => ThemeConfig
    -> Either String (ThemeInstance theme)
  validateThemeConfig =
    validateThemeInstance . Map.map SomeColor . getThemeConfig

  testQuery :: FilePath -> IO ()
  testQuery p = do
    cfg <- loadThemeConfig p
    let
      sampleQuery t = (lookupColor @"red" t, lookupColor @"blue" t)
      r = sampleQuery <$> validateThemeConfig @RuntimeTheme cfg
    print r
#+end_src

* Questions
