% Copyright 2017 Rebecca Skinner
%
% This work is licensed under the Creative Commons
% Attribution-ShareAlike 4.0 International License. To view a copy of
% this license, visit http://creativecommons.org/licenses/by-sa/4.0/
% or send a letter to Creative Commons, PO Box 1866, Mountain View, CA
% 94042, USA.
\documentclass{beamer}

\title{Monadic Error Handling in Go}
\subtitle{Breaking Beyond Common Go Idioms}
\author{Rebecca Skinner\\ \small{@cercerilla}}
\institute{Asteris, LLC}
\date{\today}

\mode<presentation> {\usetheme{metropolis}}

\usepackage[english]{babel}
\usepackage{times}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{listings-golang}
\usepackage{color}
\usepackage{amsmath}
\usepackage{csquotes}
\usepackage{verbatim}
\usepackage{fontspec}
\usepackage{pbox}

\definecolor{comment}{rgb}{145,175,188}
\definecolor{keyword}{rgb}{157,163,199}
\definecolor{string}{rgb}{155,204,174}

\lstset{ % add your own preferences
  basicstyle=\tiny,
  showspaces=false,
  showtabs=false,
  numbers=none,
  numbersep=5pt,
  showstringspaces=false,
  stringstyle=\color[rgb]{0.16, .47, 0},
  tabsize=2
}

\newcommand{\chref}[3] {
  {\color{#1} \href{#2}{\underline{#3}}}
}

\AtBeginSection[]{
  \begin{frame}
    \vfill
    \centering
    \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
      \usebeamerfont{title}\insertsectionnumber \\ \insertsectionhead\par%
    \end{beamercolorbox}
    \vfill
  \end{frame}
}

\AtBeginSubsection[]{
  \begin{frame}
    \vfill
    \centering
    \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
      \usebeamerfont{title}\insertsectionnumber.\insertsubsectionnumber\\\insertsubsectionhead\par%
    \end{beamercolorbox}
    \vfill
  \end{frame}
}

\begin{document}
\begin{frame}
  \titlepage{}
  \begin{center}
    \small{\chref{blue}{http://creativecommons.org/licenses/by-sa/4.0/}{LICENSE}}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{External Resources}
  Find links below to the source code of this presentation, as well as
  the full source code for our example application and the gofpher
  library.
  \\\vfill
  \begin{itemize}
  \item sample code: \chref{blue}{https://github.com/rebeccaskinner/agile17-sample}{agile17-sample}
  \item reference library: \chref{blue}{https://github.com/rebeccaskinner/gofpher}{gofpher}
  \item slides: \chref{blue}{https://github.com/rebeccaskinner/presentations/tree/agile-tech-2017/agile_tech_conference_2017}{source code}
  \end{itemize}
\end{frame}

\section{Introduction}
\begin{frame}
  \frametitle{Background}
  Over the last two years that I've been working with Go I've come to
  believe that some of it's idioms are a detriment to quality. In this
  presentation we'll focus on error handling, and how a decidedly
  non-idiomatic approach might make our lives simpler.
\end{frame}

\begin{frame}
  \frametitle{What We'll Cover}
  We want to understand how to improve the quality and readability of
  our code by borrowing idioms from languagues like Elm, Haskell, and
  F$\sharp$.  Here's
\end{frame}

\begin{frame}[fragile]
  \frametitle{A Lens Into Our Problem}
  At the Dunce Co. Widget Factory we realized that our employee data
  model was broken.  We've defined a new employee data model but we
  need help performing the translation. We've created a service that
  provides two endpoints:\\
  \vfill
  \begin{itemize}
  \item {\tt GET /oldusers/<id>} returns a JSON document with an old-schema user
  \item {\tt POST /newusers/<id>} accepts a JSON document with a new-schema user
  \end{itemize}
  \vfill
  Users will be provided with a list of user id's, they will call your
  application with the user id and it should fetch the old schema for
  that user, translate it to the new schema, and post that back to our
  endpoint.
\end{frame}

\section{What Makes Go Go?}
\begin{frame}
  \frametitle{Go's History}
  Go was created at Google by a team including Rob Pike and Ken
  Thompson.  It was designed to help make the development of
  microservices easier, and to address common criticisms of C++ and
  Java.  It's often called ``a better C''.
\end{frame}

\begin{frame}
  \frametitle{Easy}
  Go is a language that strives to be easy.  In most cases the
  language appears to prefer accessbility and immediate producivity,
  especially for developing small network services, over any other
  concern.

  Some key factors that keep go easy:
  \begin{itemize}
  \item Statically compiled language
  \item Rudimentary static type system, with type inference
  \item Garbage Collected
  \item {\tt go get} for libraries and tools
  \item Procedural, with C-Like syntax
  \item {\tt gofmt} and {\tt goimports} to keep code consistent
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Unambigious}
  Go's syntax was designed to be unambigious, and easily parsable by
  both humans and machines.  To this end, Go has focused on syntacic
  constructs that are specific and universal.

  Key decisions:
  \begin{itemize}
    \item Interface-only polymorphism
    \item Static type system
    \item User-defined types limited to Structs and Interfaces
  \end{itemize}
\end{frame}
\begin{frame}
  \frametitle{Obvious}
  Go is designed to be obvious, both to the writer who should not have
  to think about how to use an API, and to a reader who should be able
  to clearly understand what any piece of code is doing with minimal
  understanding of the surrounding context.
\end{frame}
\begin{frame}
  \frametitle{Idiomatic}
  Go is an opinionated language.  While many idioms are not enforced
  by the compiler, may tools exist to ensure that go code conforms to
  designed and community established idioms.
\end{frame}
%%%
\section{Error Handling in Go}
\begin{frame}
  \frametitle{A Visualization of Error Handling}
    \begin{center}
    \includegraphics[height=.85\paperheight]{images/small/curr_err_graph}
  \end{center}
\end{frame}

\subsection{Error Handling by Convention}
\begin{frame}
  \frametitle{How Do We Handle Errors?}
  Idiomatic error handling in go favors a manual and straightfoward
  approach. Each function that can fail returns an error, and each
  error is checked with, or immediately following, the call.  When an
  error occurs it is handled or propegated up the call chain until it
  can be addressed.
\end{frame}

\begin{frame}
  \frametitle{Error is an Interface}
  Errors in go typically implement the {\tt error} interface.  The
  common patterns we see with errors are:

  \begin{itemize}
  \item {\tt nil} indicates the absense of an error
  \item Specific errors are defined as constants, and compared by value
  \item Errors may be nested, to provide context for a failure
  \end{itemize}

  This approach isn't problematic per-se, but as we'll see having
  errors as their own kind of stand-alone value can cause some
  problems.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Multi-Returns}
  Go supports functions that return more than one value.  This is the
  most prominent feature of how go deals with errors. Most functions
  that can fail return a tuple of a value and an error.
  \par\pause
\begin{lstlisting}[language=Golang]
// NewFromJSON returns a new user from the deserialized json, or an error
func NewFromJSON(s []byte) (*User, error) {
        u := &User{}
        err := json.Unmarshal(s, u)
        return u, err
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{In-Line Checking}
  Go's errors are handled in line, explicitly.  By convention, each
  time a function is called that may return an error, we check the
  error immediately and
  \par\pause
\begin{lstlisting}[language=Golang]
newUserJSON, err := json.Marshal(newUser)
if err != nil {
        fmt.Println("failed to marshal new user: ", err)
        os.Exit(1)
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Error Propagation}
  When a function encounters an error in a go application, the
  conventional approach is to return it up the call chain.  Errors may
  be returned unmodified or, as in our example below, wrapped with
  context.
  \par\pause
\begin{lstlisting}[language=Golang]
func NewFromJSON(s []byte) (*User, error) {
        u := &User{}
        if err := json.Unmarshal(s, u); err != nil {
                return nil, errors.Wrap(err, "failed to deserialize JSON data")
        }
        return u, nil
}
\end{lstlisting}
\end{frame}

\subsection{The Problem with the Convention}
\begin{frame}
  \frametitle{Why Error Handling Doesn't Scale}
  Idiomatic approaches to error handling can become problematic when
  we start dealing with larger functions that have many potential
  points of failure.
  \\\vfill
  \begin{itemize}
    \item There is no enforcement mechnanism to ensure we check errors
    \item Errors are often checked several times, with potentially inconsistent handling
    \item Business logic is obscured by verbose error checking
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Error Handling Is Error Prone}
  When we are calling functions with multiple return values, go
  enforces that we capture, or explicitly ignore, each return
  value. Unfortunately, there is no way for the language to ensure
  that we are actually handling the error values.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Write Everything Twice}
  Because it's idiomatic to pass errors up the chain, it's very common
  to find our code handling ever error two or more times.

  In the example below there is a single error condition: the user did
  not supply enough command line arguments. We end up checking for the
  error twice:
  \par\pause
\begin{lstlisting}[language=Golang]
func getArgs() (*config, error) {
        args := os.Args
        if len(args) < 3 {
                return nil, errors.New("insufficient number of arguments")
        }
        return &config{endpoint: args[1], username: args[2]}, nil
}

func main() {
        config, err := getArgs()
        if err != nil {
                fmt.Println(err)
                os.Exit(1)
        }
}
\end{lstlisting}
\end{frame}

\begin{frame}
  \frametitle{Verbosity}
  Function calls in go are frequently accompanied by 3+ lines of error
  handling. This can cause several problems when we want to write
  maintainable code:
  \par\pause
  \begin{itemize}
  \item Business logic is obscured by error handling
    \pause
  \item Refactoring becomes error prone
    \pause
  \item Every additional code path adds more tests
    \pause
  \item We need more mocking ensure we're fully exercising our code paths
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The Density of Error Handing vs. Business Logic}
  \begin{center}
    \includegraphics[height=.85\paperheight]{images/small/current_errors_highlighted}
  \end{center}
\end{frame}

\section{How Can We Do Better?}
\begin{frame}
  \frametitle{Error Handling}
  {\it ``Better Code''} is hard to define in the general case, so let's
  narrow our scope down to error handling and try to define
  {\it better}.
\end{frame}

\begin{frame}
  \frametitle{What if Code Looked Like This}
  \begin{center}
    \includegraphics[width=.85\paperwidth]{images/small/monadic_highlighted}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Terseness}
  {\bf Terseness}: Using fewer statements.
  \par\pause
  Terseness is valuable (up to a point) because every statement is a
  potential error.  As we reduce the number of LOC we reduce the
  expected number of bugs in the application.
  \vfill
  \begin{itemize}
  \item Irrespective of projects defect density, more KLOC == more bugs
  \item Code on the screen is a mental cache
  \item Each branch is an opportunity for a mistake
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Expressiveness}
  {\bf Expressiveness}: The amount of meaning in a single statement.
  \par\pause
  The more meaning we pack into a statement, the fewer statements we
  have, giving us more terse code.  Expressive code is also easier to
  read because it allows a user to work at a higher level of
  abstraction and be less bogged down in the details.
  \vfill
  \begin{itemize}
  \item More meaning per statement improves terseness
  \item Higher expressiveness makes code easier to understand
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Robustness}
  {\bf Robustness}: Resiliance against mistakes, errors, and changes to the code.
  \par\pause
  Robustness in our code means that the structure of our code
  automatically guards against errors.  When we have patterns and
  idioms that help us guard against bugs without having to think about
  it, we're less likely to miss things.
  \vfill
  \begin{itemize}
  \item Prohibiting errors makes code safer
  \item Guaranteed safety makes tests simpler
  \end{itemize}
\end{frame}

\section{Monads: A Real Life Approach}
\begin{frame}
  \begin{center}
    \includegraphics[height=.85\paperheight]{images/small/burrito}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{What Are Monads?}
  A monad is a kind of very general interface that arises very
  naturally from a lot of code.  At their heart, monads give us a way
  of keeping track of context as a side effect of operating on some
  data.

  \par\pause
  An implementation of {\tt Monad} needs to be able to hold some
  data. In addition it needs to be able to support just two functions:
  \begin{itemize}
  \item {\tt Return} Creates a new container with a value in it.
  \item {\tt Bind} Takes a value in a container, and a function that
    returns a value in a container, calls the function with the value,
    and joins the two containers.
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{center}
    \includegraphics[height=.85\paperheight]{images/small/monads_visualized}
  \end{center}
\end{frame}

\section{Questions?}
\end{document}
