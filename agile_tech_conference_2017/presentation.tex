% Copyright 2017 Rebecca Skinner
%
% This work is licensed under the Creative Commons
% Attribution-ShareAlike 4.0 International License. To view a copy of
% this license, visit http://creativecommons.org/licenses/by-sa/4.0/
% or send a letter to Creative Commons, PO Box 1866, Mountain View, CA
% 94042, USA.
\documentclass{beamer}

\title{Monadic Error Handling in Go}
\subtitle{Breaking Beyond Common Go Idioms}
\author{Rebecca Skinner\\ \small{@cercerilla}}
\institute{Asteris, LLC}
\date{\today}

\mode<presentation> {\usetheme{metropolis}}

\usepackage[english]{babel}
\usepackage{times}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{listings-golang}
\usepackage{color}
\usepackage{amsmath}
\usepackage{csquotes}
\usepackage{verbatim}
\usepackage{fontspec}
\usepackage{pbox}

\definecolor{comment}{rgb}{145,175,188}
\definecolor{keyword}{rgb}{157,163,199}
\definecolor{string}{rgb}{155,204,174}

\lstset{ % add your own preferences
  basicstyle=\tiny,
  showspaces=false,
  showtabs=false,
  numbers=none,
  numbersep=5pt,
  showstringspaces=false,
  stringstyle=\color[rgb]{0.16, .47, 0},
  tabsize=2
}

\newcommand{\chref}[3] {
  {\color{#1} \href{#2}{\underline{#3}}}
}

\AtBeginSection[]{
  \begin{frame}
    \vfill
    \centering
    \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
      \usebeamerfont{title}\insertsectionnumber \\ \insertsectionhead\par%
    \end{beamercolorbox}
    \vfill
  \end{frame}
}

\AtBeginSubsection[]{
  \begin{frame}
    \vfill
    \centering
    \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
      \usebeamerfont{title}\insertsectionnumber.\insertsubsectionnumber\\\insertsubsectionhead\par%
    \end{beamercolorbox}
    \vfill
  \end{frame}
}

\begin{document}
\begin{frame}
  \titlepage{}
  \begin{center}
    \small{\chref{blue}{http://creativecommons.org/licenses/by-sa/4.0/}{LICENSE}}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{External Resources}
  Find links below to the source code of this presentation, as well as
  the full source code for our example application and the gofpher
  library.
  \\\vfill
  \begin{itemize}
  \item sample code: \chref{blue}{https://github.com/rebeccaskinner/agile17-sample}{agile17-sample}
  \item reference library: \chref{blue}{https://github.com/rebeccaskinner/gofpher}{gofpher}
  \item slides: \chref{blue}{https://github.com/rebeccaskinner/presentations/tree/agile-tech-2017/agile_tech_conference_2017}{source code}
  \end{itemize}
\end{frame}

\section{Introduction}
\begin{frame}
  \frametitle{What Are We \emph{Go}-ing To Cover?}
  We want to understand how to improve the quality and readability of
  our code by borrowing idioms from languagues like Elm, Haskell, and
  F$\sharp$.  Here's how we'll get there
  \\\vfill
  \begin{itemize}
  \item Go Today: What Works and Why I Was Motivated to Do Better
  \item Defining Better: How A New Approach Can Improve Quality
  \item Abstracting Program Structure: An Introduction to Monadic Error Handling
  \item Generalization: Applying Today's Lessons Tomorrow
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A Lens Into Our Problem}
  At the Dunce Co. Widget Factory we realized that our employee data
  model was broken.  We've defined a new employee data model but we
  need help performing the translation. We've created a service that
  provides two endpoints:\\
  \vfill
  \begin{itemize}
  \item {\tt GET /oldusers/<id>} returns a JSON document with an old-schema user
  \item {\tt POST /newusers/<id>} accepts a JSON document with a new-schema user
  \end{itemize}
  \vfill
  Users will be provided with a list of user id's, they will call your
  application with the user id and it should fetch the old schema for
  that user, translate it to the new schema, and post that back to our
  endpoint.
\end{frame}

\section{The State of Go in 2017}
\begin{frame}
  \frametitle{Go's History}

  Go was created at Google by a team including Rob Pike and Ken
  Thompson.  It was designed to help make the development of
  microservices easier, and to address common criticisms of C++ and
  Java.  It's often called ``better C''.
\end{frame}

\begin{frame} [fragile]
  \frametitle{Simple Syntax}

  Go was designed to have syntax that is very similar to languages in
  the C family.
\\\vfill
\begin{lstlisting}[language=Golang]
package main
import "fmt"
func main() {
        fmt.Println("Hello, World")
}
\end{lstlisting}
\end{frame}

\begin{frame}
  \frametitle{Static Types}
  Go is a statically typed language.  The empty interface type {\tt
    interface$\{\}$} allows us to escape the type system and work
  with untyped data.
\end{frame}

\begin{frame} [fragile]
  \frametitle{Reflection}
  Go supports runtime type introspection with reflect.  Using
  reflection we can look up the original type of an untyped variable:
\\\vfill
\begin{lstlisting}[language=Golang]
func wasInt(i interface{}) bool {
        return reflect.TypeOf(i) == reflect.TypeOf(int(0))
}
\end{lstlisting}
\end{frame}

\begin{frame}
  \frametitle{OOP}

  Go supports, but does not enforce, object oriented programming.
  {\tt struct}'s may act as objects by having methods attached to
  them, or they can act as plain structured data.

  Interfaces are descriptive.  When an interface is defined, any type
  that implements the required methods will fullfill the interface
  automatically.  This allows interfaces to be created on top of
  existing types without changing the underlying implementation.
\end{frame}

\begin{frame}[fragile]
  \frametitle{First-Class Functions}

  Go supports first-class functions, which are closed over the
  variables that are in scope when they are defined.  Defining
  functions in-line to pass to other functions is idiomatic and common
  in go.  The example below shows how first-class functions are
  commonly used during unit testing.
\\\vfill
\begin{lstlisting}[language=Golang]
t.Run("params-and-lookups", func(t *testing.T) {
        assert.True(t, graphutils.DependsOn(g, "parent-1", "child-1"))
        assert.True(t, graphutils.DependsOn(g, "parent-1", "child-2"))
})
\end{lstlisting}
\end{frame}

\begin{frame}
  \frametitle{Multi-Returns}

\end{frame}

\subsection{Generics, Interfaces, and \tt{interface\{\}}}
\subsection{First Class Functions}
\subsection{Multi-Return}
\subsection{Error Handling}
\section{Defining \emph{Better}}
\subsection{Some Definitions of Better}
\begin{frame}
  \frametitle{Terseness}
  {\bf Terseness}: Using fewer statements.
  \vfill
  Terseness is valuable (up to a point) because every statement is a
  potential error.  As we reduce the number of LOC we reduce the
  expected number of bugs in the application.
  \vfill
  \begin{itemize}
  \item Irrespective of projects defect density, more KLOC == more bugs
  \item Code on the screen is a mental cache
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Expressiveness}
  {\bf Expressiveness}: The amount of meaning in a single statement.
  \vfill
  The more meaning we pack into a statement, the fewer statements we
  have, giving us more terse code.  Expressive code is also easier to
  read because it allows a user to work at a higher level of
  abstraction and be less bogged down in the details.
  \vfill
  \begin{itemize}
  \item More meaning per statement improves terseness
  \item Higher expressiveness makes code easier to understand
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Robustness}
  {\bf Robustness}: Resiliance against mistakes, errors, and changes to the code.
  \vfill
  Robustness in our code means that the structure of our code
  automatically guards against errors.  When we have patterns and
  idioms that help us guard against bugs without having to think about
  it, we're less likely to miss things.
  \vfill
  \begin{itemize}
  \item Prohibiting errors makes code safer
  \item Guaranteed safety makes tests simpler
  \end{itemize}
\end{frame}
\section{Abstracting Structure}
\subsection{Content vs Structure}

\begin{frame}
  \frametitle{Content and Structure}
  {\bf Structure:} The shape of the code; the way units of functionality are assembled.

  \vfill

  The key difference between our examples is in how we handle
  structure.  In the first case the structure is verbose, and in the
  second it's completely absent.

  \vfill
\end{frame}

\begin{frame}[fragile]
  \frametitle{Encoding Structure}
\begin{lstlisting}
type ExampleFunc func(interface{}) (interface{}, error)

func ExampleStructure(input interface{},
        func1 ExampleFunc,
        func2 ExampleFunc) (interface{}, error) {
        result1, err := func1(input)
        if err != nil {
                return err
        }
        return func2(result1)
}
\end{lstlisting}
  \vfill
  We could encode our structure in a function that checks the result for us
\end{frame}

\begin{frame}[fragile]
  \frametitle{Using the Example}
\begin{lstlisting}
func ShowExample(input interface{}) (interface{}, error) {
        result, err := ExampleStructure(input, operation1, operation2)
        if err != nil {
                return err
        }
        return operation3(result)
}
\end{lstlisting}
  \vfill
  But we still have the same problem...
\end{frame}

\begin{frame}[fragile]
  \frametitle{If we return the same type that we input...}
\begin{lstlisting}
type ExampleFunc func(interface{}) (interface{}, error)

func BetterExample(f1, f2 ExampleFunc) ExampleFunc {
        return func(input interface{}) (interface{}, error) {
                result1, err := f1(input)
                if err != nil {
                        return nil, err
                }
                return f2(result1)
        }
}

func UseExample(input interface{}) (interface{}, error) {
        f := BetterExample(BetterExmaple(operation1, operation2), operation3)
        return f(input)
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{But now we're tied to {\tt (interface{}, error)}}

  We can create a custom structure for each place in our code, but
  it's better when we have a common language.

  \begin{itemize}
  \item Things that represent structure
  \item A way to chain operations together
  \item Decoupled from the underlying shape of our data
  \end{itemize}
\end{frame}
\subsection{Monads}

\begin{frame}
  \frametitle{Monads Formalize Structure}

  Monads formalize structure, and let us program with structure
  separate from the code that the structure is controlling.
\end{frame}

\subsection{Monads in Practice}

\begin{frame}[fragile]
  \frametitle{Monad Interface}
\begin{lstlisting}
type Monad interface {
        AndThen(func(interface{}) Monad) Monad
        Return(i interface{}) Monad
}

func (m Either) AndThen(f func(interface{}) monad.Monad) monad.Monad {
        if m.IsLeft() {
                return m
        }
        inner, ok := m.inner.(RightType)
        if !ok {
                return Left(errors.New("invalid either type"))
        }
        return f(inner.Val)
}

func (m Maybe) AndThen(f func(interface{}) monad.Monad) monad.Monad {
        if asJust, ok := m.internal.(just); ok {
                return f(asJust.Val)
        }
        return m
}
\end{lstlisting}
\end{frame}
\section{Generalizing Idioms}
\section{Questions?}

\begin{frame}
  \frametitle{Let's Write Better Code!}
  Go introduces some novel language features.  The community have
  standardized on some idioms that work, but can we do better?
\end{frame}

\begin{frame}
  \frametitle{Error Handling}
  {\it ``Better Code''} is hard to define in the general case, so let's
  narrow our scope down to error handling and try to define
  {\it better}.
\end{frame}
\end{document}
