\documentclass{beamer}
\usefonttheme[onlymath]{serif}

\title{The Language of Languages}
\subtitle{Or \\ \small{Understanding the language of the mathematics of programming}}
\author{Rebecca Skinner}
\institute{CenturyLink Cloud}
\date{\today}
\mode<presentation> {\usetheme{Madrid}}

\usepackage[english]{babel}
\usepackage[latin1]{inputenc}
\usepackage{times}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}
\usepackage{amsmath}
\usepackage{csquotes}
\usepackage{verbatim}

% CenturyLink Green
\usecolortheme[RGB={16,117,48}]{structure}

\definecolor{comment}{rgb}{0,0.6,0}
\definecolor{keyword}{rgb}{0,0,0.6}
\definecolor{string}{rgb}{0.58,0,0.82}

\lstset{
  backgroundcolor=\color{white},
  basicstyle=\tiny,
  keywordstyle=\color{keyword},
  commentstyle=\color{comment},
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  stringstyle=\color{string},
  tabsize=4
}

\newcommand{\chref}[3] {
  {\color{#1} \href{#2}{\underline{#3}}}
}

\AtBeginSection[]{
  \begin{frame}
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\insertsectionnumber \\ \insertsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}

\AtBeginSubsection[]{
  \begin{frame}
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\insertsectionnumber.\insertsubsectionnumber\\\insertsubsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}

\begin{document}

\begin{frame}
  \titlepage{}
\end{frame}

\section{Algebra}
\subsection{Understanding Algebras}
\begin{frame}
  \frametitle{\it{A} is for Algebra}
  \textquote{Algebra is the manipulation of symbols without (necessarily)
    regard for their meaning, especially in a way that can be
    formalized in cartesian logic.} - $\eta$-Lab
\end{frame}

\begin{frame}
  \frametitle{An Algebra is...}
  An alegbra is, essentially
  \begin{itemize}
    \item A set of things you can operate on
    \item A set of operations you can perform
    \item A set of axioms that define how you can reason about things
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Examples of Algebras}
  Many things that we've done in or heard about in mathematics can be
  defined as algebras.
  \begin{itemize}
    \item Monoids
    \item Boolean Algebra
    \item Vector Spaces (Linear Algebra)
    \item Arithmetic (Abelian Group)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{A Programming Language is an Algebra}
  A programming language also defines an algebra. This algebra is what
  defines all of the things that we can do with the language. Normal
  arithmetic is part of the algebra, but other things may be as well.
\end{frame}

\begin{frame}
  \frametitle{\dots In fact, many of them}
  Although the set of fundametal operators that can act on any entity
  defined within the language forms an algebra, there are are also
  often other algebras that are more fully featured and exit for
  individual things defined in the language.
  \begin{itemize}
    \item List Operations
      \begin{itemize}
        \item cons
        \item map
        \item sort
      \end{itemize}
    \item Numbers
      \begin{itemize}
        \item arithmetic
      \end{itemize}
    \item Objects
      \begin{itemize}
        \item send message
        \item instantiate
        \item delete
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{And you build your own}
  Interfaces, class, and instance method are common ways of defining
  algebras.  The class is the domain of your algebra, and instance
  methods define your algebraic structure.
\end{frame}

\begin{frame}
  \frametitle{Talking about Algebras}

  When talking about an algebra we define {\tt operators} and
  {\tt variables}.  The dot operator ($\cdot$) is the canonical
  operator defined for an algebra.  Sometimes other operators such as
  ($+$), ($\rightarrow$), ($\cap$), or ($\sqsubseteq$) are also
  defined.

  Remember that when talking about an algebra with operators $\cdot$
  and $+$, these aren't necessarily analagous to the arithmetic
  multiplcation and addition operations!
\end{frame}

\begin{frame} [fragile]
  \frametitle{Writing Expressions Algebraically}
  In a language like ruby we may express the idea of our algebra like a function call:
  \begin{verbatim}
  c = [1,2,3].zip [:a, :b, :c]
\end{verbatim}
  which, in the context of an algebra over lists that defines an operator zip as $\cdot$ then we might write:
  $c = { 1, 2, 3 } \cdot { a, b, c}$
\end{frame}

\begin{frame}
  \frametitle{Types of Algebraic Structures Used in Software}

  Although much formal programming language theory describe
  applications in terms of \emph{Category Theory} and the languages'
  \emph{Denotional Semantics}, it can be conceptually useful to think
  of the semantics of an application in terms of Sets and Groups.
\end{frame}

\subsection{Properties of Algebraic Structures}

\begin{frame}
  \frametitle{Associativity}
  An associative algebra is one that ensures that the order of
  operations in sequential applications of an operator is
  inconsequential as long as the order of the operands remains
  unchanges.
  $ a \cdot ( b \cdot c) = ( a \cdot b ) \cdot c $
\end{frame}

\begin{frame}
  \frametitle{Communitivity}
  A Communitive algebra is one where the order of the operands doesn't matter.
  $ a \cdot b = b \cdot a$
\end{frame}

\begin{frame}
  \frametitle{Closure}
  An algebraic structure is \emph{closed} over an operation, $\cdot$ if: \\
  $\forall a, b \epsilon A$ \\then \\$(a \cdot b) \epsilon A$
\end{frame}

\begin{frame} [fragile]
  \frametitle{Identity}
  An algebraic structure may be considered to cotain an \emph{identity
    element} if for each binary operation, there exists some element
  which, when applied with some other element, returns at element.
  \begin{center}
  $\forall a \epsilon A$\\
  $id \cdot a = a $
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Initial Algebras}
  An initial algebra is an algebra in the category of algebras.  It
  defines an entry point into a recursive structure.  An initial
  algebra formalizes the concept of things like an empty list.
\end{frame}

\subsection{Why Formalize Algebras?}

\begin{frame}
  \frametitle{Communication}
  Leverage common, concise, and precise notation for describing your application behavior.
\end{frame}

\begin{frame}
  \frametitle{Equational Reasoning}
  Think about extensions to your problem space, and your solutions,
  abstractly by leverging analogous tools for different problem
  domains that represent the same algebra.
\end{frame}

\begin{frame}
  \frametitle{Testing}
  Defining an algebra can be the natrual evolution of testing as your
  tests are essentially defining your axioms and operators.
\end{frame}

\section{The Algebra of Types}

\subsection{A Question}

\begin{frame}[fragile]
  \frametitle{Example 1}
  Looking at a very simple typed program we can see how types can help
  us understand what a program is doing.  Look at the example below
  and let's talk about what it's doing.
  \begin{exampleblock}{A Very Simple Program}
    \begin{lstlisting}[language=haskell]
addNumbers :: Int -> Int -> Int
addNumbers x y = x + y

doubleNumber :: Int -> Int
doubleNumber x = addNumbers x x

doubleFive :: Int
doubleFive =
  let x = 5 :: Int in
    doubleNumber x
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Example 2}
  In this example we lack type annotations for our functions.  Can we
  figure out what it's doing?
  \begin{exampleblock}{A More Obscure One}
    \begin{lstlisting}[language=haskell]
obscureFunction x y = x !! y

obscureerFunction =
  let x = [1,2,3,4,5] in
    let y = 2 :: Int in
      obscureFunction x y
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\subsection{A Glossary of Type Algebra}

\begin{frame}
  \frametitle{Free Variables}

  We say that $x$ is \emph{free} when it is not bound to a value or
  set of values (a type).  When we use $x$ in an expression, $x$
  becomes bound by the judgement we have made about that expression.
  For example if we say $f : \tau \rightarrow \tau'$, then in the
  expression $\lambda x. f x$ x becomes bound by the restriction that
  $x : \tau$ and the expression $(\lambda x . f x) x : \tau'$

\end{frame}


\begin{frame}
  \frametitle{:}
  Type assignment is an assertion that a given variable has a given
  type.  We write $x : \tau$ to say that $x$ has type $\tau$.
  \begin{exampleblock}{Type Assignment}
    \[
      x : \text{Integer}
    \]
  \end{exampleblock}
\end{frame}

\begin{frame}
  \frametitle{$\Gamma$}
  $\Gamma$ represents a \emph{type context}, the context for which
  types exist, and what variables are bound to them.  We can add
  additional context to a type context by additing additional comma
  separated clauses.
  \begin{exampleblock}{A Type Context}
    \[
      \Gamma' = x : \sigma, \Gamma
    \]
  \end{exampleblock}

\end{frame}

\begin{frame}
  \frametitle{$\vdash$}
  The $\vdash$ operator provides a \emph{type judgement}.  A type
  judgement is a judgement that given a context, $\Gamma$, that a type
  assignment, $x : \sigma$ holds.
  \begin{exampleblock}{Type Judgements}
    \[
      \Gamma \vdash x : \sigma
    \]
  \end{exampleblock}
\end{frame}

\begin{frame}
  \frametitle{\---}
  \begin{exampleblock}{Propositions}
    \[
      \frac{\Gamma, x : \tau}{\Gamma \vdash x : \tau}
    \]
  \end{exampleblock}
\end{frame}

\begin{frame}
  \frametitle{$\sqsubseteq$}
  The $\sqsubseteq$ operator specifies \emph{specialization}.  To say
  that $\tau \sqsubseteq \sigma$ is to that that the type $\tau$ is a
  specialization of the general type $\sigma$
  \begin{exampleblock}{Specialization}
    \[
      \frac{\Gamma' = \Gamma, x : \text{Int} \quad \text{Int} \sqsubseteq \text{Number}}
      {\Gamma' \vdash x : \text{Number} }
    \]
  \end{exampleblock}
\end{frame}

\subsection{An Example: Hindley Milner}

\begin{frame}
  \frametitle{Variable Definition}
  Variable definition as defined by let encapsulates the idea of
  assigning a type, $\sigma$, to a variable, $x$, in a given context
  $\Gamma$.

  \begin{exampleblock}{Var}
    \[
      \frac{x:\sigma \in \Gamma \quad \tau \sqsubseteq \sigma}{\Gamma \vdash x : \tau}
    \]
  \end{exampleblock}
\end{frame}

\begin{frame}
  \frametitle{Application}
  Application encapsulates the idea of function application. It
  formalizes the notion that a function from a variable of one type to
  a result of another type a type allows us to make a type judgement
  about the result of applying that function.
  \begin{exampleblock}{App}
    \[
      \frac{\Gamma \vdash e_0 : \tau \rightarrow \tau' \quad \Gamma \vdash e_1 : \tau}
      {\Gamma \vdash e_0\, e_1 : \tau'}
    \]
  \end{exampleblock}
\end{frame}

\begin{frame}
  \frametitle{Abstraction}
  Abstraction generalizes the concept of abstracting a type over a
  function.  For any type, $\tau'$, we can create a function that
  generalizes $\tau'$ over $\tau$ by creating a function from
  $\tau \rightarrow \tau'$

  \begin{exampleblock}{Abs}
    \[
      \frac{\Gamma, x : \tau \vdash e : \tau'}
      {\Gamma \vdash \lambda x\, .\, e : \tau \rightarrow \tau'}
    \]
  \end{exampleblock}
\end{frame}

\begin{frame}
  \frametitle{Generalization}
  We define the function $\bar{\Gamma}(\tau)$ as the set of mono-typed
  variables that are not bound in $\tau$ but are in the type context
  $\Gamma$. When we say $\Gamma, x : \bar{\Gamma}(\tau)$ we are
  asserting that in the context $\Gamma$ that $x$ is free with respect
  to $\tau$
  \begin{exampleblock}{Gen}
    \[
      \bar{\Gamma}(\tau) = \forall \hat{\alpha} . \tau \quad \hat{\alpha} = \text{free}(\tau) - \text{free}(\Gamma)
    \]
  \end{exampleblock}
\end{frame}

\begin{frame}

  {\tt let} uses $\bar{\Gamma}(\tau)$ to define the concept of
  substitution in an expression.  When we know that $e_0 : \tau$ and
  $e_1 : \tau$ in $\Gamma, x:\bar{\Gamma}(\tau)$ then we can infer
  that by substituting $e_0$ in $\lambda x . e_1$ where $x$ was not
  bound to $\tau$, we have $\tau \rightarrow \tau'$.  This allows us
  to define \emph{let-polymorphism}.

  \frametitle{Let Bindings}
  \begin{exampleblock}{Let}
    \[
      \frac{\Gamma \vdash e_0 : \tau \quad \Gamma, x : \bar{\Gamma}(\tau) \vdash e_1 : \tau'}
      {\Gamma \vdash \text{let}\, x\; =\; e_0\; \text{in}\; e_1 : \tau'}
    \]
  \end{exampleblock}
\end{frame}

\subsection {A bit more on let-polymorphism}

\begin{frame}[fragile]
  \frametitle{Let Polymorphism Explained}
  Consider the following sample code
  \begin{exampleblock}{Sample Code}
    \begin{lstlisting}[language=Haskell]
thingInt y = let x = 5 :: Int in x + y
main = let value = 7 in print (thingInt value)
    \end{lstlisting}
  \end{exampleblock}

  \begin{exampleblock}{Sample Output}
    \begin{verbatim}
    [rebecca@localhost:~] runhaskell sample.hs
    12
\end{verbatim}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Let Polymorphism Explained (2)}
  Consider the following sample code
  \begin{exampleblock}{Sample Code}
    \begin{lstlisting}[language=Haskell]
thingFloat y = let x = 5 :: Float in x + y
main = let value = 7 in print (thingInt value)
    \end{lstlisting}
  \end{exampleblock}

  \begin{exampleblock}{Sample Output}
    \begin{verbatim}
    [rebecca@localhost:~] runhaskell sample.hs
    12.0
\end{verbatim}
  \end{exampleblock}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Let Polymorphism Explained (3)}
  Consider the following sample code
  \begin{exampleblock}{Sample Code}
    \begin{lstlisting}[language=Haskell]
thingInt y = let x = 5 :: Int in x + y
thingFloat y = let x = 5 :: Float in x + y
main = let value = 7 in print (thingInt value) >> print (thingFloat value)
    \end{lstlisting}
  \end{exampleblock}

\begin{exampleblock}{Sample Output}
  \begin{tiny}
    \begin{verbatim}
    [rebecca@localhost:~] runhaskell sample.hs

    sample.hs:3:69:
        Couldn't match expected type 'Float' with actual type 'Int'
        In the first argument of 'thingFloat', namely 'value'
        In the first argument of 'print', namely '(thingFloat value)'
\end{verbatim}
\end{tiny}
  \end{exampleblock}

\begin{exampleblock}{Sample Output}
  \begin{tiny}
    \begin{verbatim}
    [rebecca@localhost:~] runhaskell -XNoMonomorphismRestriction sample.hs
    12
    12.0
\end{verbatim}
\end{tiny}
\end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{No Monomorphism Restriction}
  The {\tt -XNoMonomorphismRestriction} flag allows let-polymorphism
  at the expression level, by removing the restriction that $x$ must
  remain bound within the context of {\tt main}.  With the restriction
  lifted $x$ becomes \emph{free} within the second expression
  {\tt print (thingFloat)} and is no longer bound by the restriction
  $x : \text{Int}$
\end{frame}

\end{document}
